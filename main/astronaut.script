local SPEED = 250
local TILE_SIZE = 64;            -- must match your tilesource cell size
local TILE_LAYER = "collision";  -- name of your collision layer

local TILEMAP_GO_URL  = msg.url("main:/level")          -- the GO that holds the tilemap
local TILEMAP_URL     = msg.url("main:/level#level")    -- the tilemap component

local function world_to_tile(p)
	-- Convert world space to tilemap-local space by subtracting the tilemap GO position
	local tm_pos = go.get_world_position(TILEMAP_GO_URL);
	local lx = p.x - tm_pos.x;
	local ly = p.y - tm_pos.y;
	-- Defold tilemaps are 1-based: add +1 after flooring
	local tx = math.floor(lx / TILE_SIZE) + 1;
	local ty = math.floor(ly / TILE_SIZE) + 1;
	return tx, ty;
end

local function is_solid_at(world)
	local tx, ty = world_to_tile(world);
	local tile_id = tilemap.get_tile(TILEMAP_URL, TILE_LAYER, tx, ty);
	-- Tile 7 is passable (damaged rock state)
	return tile_id ~= 0 and tile_id ~= 7;
end

local function can_move_to(aabb_half, target_pos)
	-- sample four AABB corners against the collision layer
	local corners = {
		vmath.vector3(target_pos.x - aabb_half.x, target_pos.y - aabb_half.y, 0),
		vmath.vector3(target_pos.x + aabb_half.x, target_pos.y - aabb_half.y, 0),
		vmath.vector3(target_pos.x - aabb_half.x, target_pos.y + aabb_half.y, 0),
		vmath.vector3(target_pos.x + aabb_half.x, target_pos.y + aabb_half.y, 0),
	};
	for i = 1, #corners do
		if is_solid_at(corners[i]) then return false end;
	end
	return true;
end

local function axis_to_vec(input)
	local dx = (input.right and 1 or 0) - (input.left and 1 or 0);
	local dy = (input.up    and 1 or 0) - (input.down and 1 or 0);
	if dx ~= 0 or dy ~= 0 then
		local len = math.sqrt(dx*dx + dy*dy);
		dx, dy = dx/len, dy/len; -- even diagonal speed
	end
	return dx, dy;
end

local function point_in_astronaut(astronaut_pos, click_pos, size)
	-- Check if click position is within astronaut bounds
	local sprite_center = astronaut_pos + vmath.vector3(0, 48, 0) -- Sprite center offset
	local half_size = size * 0.5
	return (click_pos.x >= sprite_center.x - half_size.x and
			click_pos.x <= sprite_center.x + half_size.x and
			click_pos.y >= sprite_center.y - half_size.y and
			click_pos.y <= sprite_center.y + half_size.y)
end

local function calculate_slingshot_force(drag_vector)
	-- Convert drag distance to projectile force
	local drag_length = vmath.length(drag_vector)
	local max_drag_distance = 100 -- Maximum drag distance for max force
	local max_force = 800 -- Maximum projectile force

	local force_magnitude = math.min(drag_length / max_drag_distance, 1.0) * max_force

	-- Direction is opposite of drag (slingshot effect)
	local direction = vmath.vector3(0, 0, 0)
	if drag_length > 0 then
		direction = -vmath.normalize(drag_vector)
	end

	return direction, force_magnitude
end

function init(self)
	msg.post(".", "acquire_input_focus")
	self.input = {left=false,right=false,up=false,down=false};
	self.half = vmath.vector3(24, 16, 0); -- hitbox for feet/bottom area only
	self.current_anim = nil
	self.facing_direction = vmath.vector3(0, -1, 0); -- default facing down
	self.is_moving = false

	-- Slingshot shooting variables
	self.is_dragging = false
	self.drag_current_pos = vmath.vector3()
	self.astronaut_sprite_size = vmath.vector3(48, 96, 0) -- Approximate sprite size for click detection
end

function final(self)
	msg.post(".", "release_input_focus");
end

function update(self, dt)
	-- Draw slingshot line if dragging
	if self.is_dragging then
		local astronaut_pos = go.get_position()
		local center_pos = astronaut_pos + vmath.vector3(0, 48, 0) -- Sprite center
		msg.post("@render:", "draw_line", {
			start_point = center_pos,
			end_point = self.drag_current_pos,
			color = vmath.vector4(1, 1, 1, 0.8) -- White with some transparency
		})
	end

	local anim = self.current_anim
	local dx, dy = axis_to_vec(self.input)
	local moving = (dx ~= 0 or dy ~= 0)

	-- Update facing direction and animation when moving
	if dx < 0 then
		anim = hash("left")
		self.facing_direction = vmath.vector3(-1, 0, 0)
	elseif dx > 0 then
		anim = hash("right")
		self.facing_direction = vmath.vector3(1, 0, 0)
	elseif dy > 0 then
		anim = hash("back")
		self.facing_direction = vmath.vector3(0, 1, 0)
	elseif dy < 0 then
		anim = hash("front")
		self.facing_direction = vmath.vector3(0, -1, 0)
	else
		-- When stopped, switch to idle only if facing front, otherwise keep current animation
		if self.facing_direction == vmath.vector3(0, -1, 0) then
			anim = hash("idle")
		else
			anim = self.current_anim
		end
	end

	-- Play animation if changed
	if anim ~= self.current_anim then
		sprite.play_flipbook("#sprite", anim)
		self.current_anim = anim
	end

	-- Control animation playback based on movement
	if moving and not self.is_moving then
		-- Just started moving - ensure animation is playing
		go.set("#sprite", "playback_rate", 1)
	elseif not moving and self.is_moving then
		-- Just stopped moving
		if anim == hash("idle") then
			-- Keep idle animation playing
			go.set("#sprite", "playback_rate", 1)
		else
			-- Pause animation for directional sprites
			go.set("#sprite", "playback_rate", 0)
		end
	end

	self.is_moving = moving

	if dx == 0 and dy == 0 then return end
		
	local pos = go.get_position();
	local intended = pos + vmath.vector3(dx * SPEED * dt, dy * SPEED * dt, 0);

	-- separate axis resolution: try X, then Y
	local try_x = vmath.vector3(intended.x, pos.y, 0);
	if can_move_to(self.half, try_x) then pos.x = try_x.x end

	local try_y = vmath.vector3(pos.x, intended.y, 0);
	if can_move_to(self.half, try_y) then pos.y = try_y.y end

	go.set_position(pos);
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Remove this function if not needed
end

function on_input(self, action_id, action)
	if action.pressed or action.released then
		local down = action.pressed
		if action_id == hash("left")  then self.input.left  = down end
		if action_id == hash("right") then self.input.right = down end
		if action_id == hash("up")    then self.input.up    = down end
		if action_id == hash("down")  then self.input.down  = down end
	end

	-- Slingshot shooting with mouse
	if action_id == hash("touch") then
		local mouse_pos = vmath.vector3(action.x, action.y, 0)
		local astronaut_pos = go.get_position()

		if action.pressed then
			-- Check if click is on astronaut
			if point_in_astronaut(astronaut_pos, mouse_pos, self.astronaut_sprite_size) then
				self.is_dragging = true
				self.drag_current_pos = mouse_pos
			end
		elseif action.released and self.is_dragging then
			-- Fire projectile based on drag
			local drag_vector = self.drag_current_pos - go.get_position()
			local direction, force = calculate_slingshot_force(drag_vector)

			if vmath.length(drag_vector) > 10 then -- Minimum drag distance
				local pos = go.get_position()
				local center_offset = vmath.vector3(0, 48, 0)
				local spawn_pos = pos + center_offset
				spawn_pos.z = 0.5

				local props = {
					position = spawn_pos,
				}
				local id = factory.create("#projectile_factory", spawn_pos, nil, props)
				msg.post(id, "set_direction", {direction = direction, force = force})
			end

			self.is_dragging = false
		end

		-- Update drag position while dragging
		if self.is_dragging then
			self.drag_current_pos = mouse_pos
		end
	end

	-- Keep original spacebar shooting for backup
	if action_id == hash("fire") and action.pressed then
		local pos = go.get_position()
		-- Offset to sprite center (sprite is at y+48 from game object position)
		local adjustment = vmath.vector3(0, 0, 0)
		if self.facing_direction == vmath.vector3(0, -1, 0) then
			adjustment = adjustment + vmath.vector3(6, 16, 1)
		end

		local center_offset = vmath.vector3(0, 48, 0) + adjustment
		local direction_offset = self.facing_direction * 48
		local spawn_pos = pos + center_offset + direction_offset
		spawn_pos.z = 0.5  -- Set z-position for layering (higher = in front)
		local props = {
			position = spawn_pos,
		}
		local id = factory.create("#projectile_factory", spawn_pos, nil, props)
		msg.post(id, "set_direction", {direction = self.facing_direction})
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Remove this function if not needed
end